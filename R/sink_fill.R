#' Fill the sinks with a dem
#'
#' @description The sink filling algorithm of Planchona and Darboux 2001
#'
#' @param stck a RasterStack object as generated by create_catchment
#' @param min_grad Minimum gradient between cell centres
#' @param max_it maximum number of replacements to trial
#' @param verbose pront out additional diagnostic information
#' @param ... additional variables passed to raster::stack if stck is a file name
#' @return an altered RasterStack object with the filled_dem populated.
#'
#' @details The algorithm implimented in Planchona and Darboux, "A fast, simple and versatile algorithm to fill the depressions in digital elevation models" Catena 46 (2001). A pdf can be found at https://horizon.documentation.ird.fr/exl-doc/pleins_textes/pleins_textes_7/sous_copyright/010031925.pdf.
#'
#' If stck is a character object it is presemed to be the path to a file containing the catchment RasterStack. If so it read in and overwritten with the result using the raster package.
#'
#' @export
sink_fill <- function(ctch,min_grad = 1e-4,max_it=1e6,verbose=FALSE,...){

    check_catchment(ctch,c("dem","land_area","channel_area","channel_id"))
    
    ## extract dem and channel_id values
    z <- raster::getValues(stck[['dem']])
    ch_id <- raster::getValues(stck[['channel_id']])

    w <- ctch$layers$dem
    w[!is.na(w)] <- Inf
    w[is.finite(ctch$layers$channel_id)] <- ctch$layers$dem[is.finite(ctch$layers$channel_id)]

    ## get properties of required from ctch
    dx <- mean(ctch$raster$res)
    nc <- ctch$raster$dim[2]
    nr <- ctch$raster$dim[1]

    idx <- which(!is.na(w))

    something_done <- TRUE
    it <- 1
    while( something_done ){
        if( verbose ){
            print(paste("Iteration",it))
        }
        something_done <- FALSE
        for(ii in idx){
            if( w[ii] > ctch$layers$dem[ii] ){
                ## then need to investigate
                ## compute neighbours
                jj <- fN(ii,nr,nc,dx)
                w_min <- min(w[jj$idx]+jj$dx*min_grad,na.rm=TRUE)
                if( ctch$layers$dem[ii] > w_min ){
                    ## set to ctch$layers$dem and leave
                    w[ii] <- ctch$layers$dem[ii]
                    something_done <- TRUE
                }else{
                    if( w[ii] > w_min ){
                        w[ii] <- w_min
                        something_done <- TRUE
                    }
                }
            }
        }
        if( it > max_it ){
            warning("Maximum number of iterations reached, sink filling not complete")
            something_done <- FALSE # cause end of while loop
        }
        it <- it+1
        #print(sum(is.finite(w)))
    }

    ## copy filled dem back into stack
    ctch$layers$filled_dem <- w

    return(ctch)
}
