#' Fill the sinks with a dem
#'
#' @description TO DO
#'
#' @param stck a RasterStack object as generated by create_catchment
#' @param max_it maximum number of replacements to trial
#' @param ... additional variables passed to raster::stack if stck is a file name
#' @return an altered RasterStack object with the filled_dem populated.
#'
#' @details Sinks are then identified as either having an Inf dem values or by not having a lower neighbour. Sinks are replaced in order of the lowest neighbouring value (min first) by the mean of the adjacent finite value cells. See Vignette for a more detailed desciption.
#'
#' If stck is a character object it is presemed to be the path to a file containing the catchment RasterStack. If so it read in and overwritten with the result using the raster package.
#'
#' @export
sink_fill <- function(stck,max_it=1e6,...){

    if(!("RasterStack" %in% class(stck))){
        if( is.character(stck) ){
            stck_file <- stck
            stck <- raster::stack(stck,...)
        }else{
            stop("Unknown stck format")
        }
    }else{
        stck_file <- character(0)
    }

    check_catchment(stck)

    ## extract dem and channel_id values
    dem <- raster::getValues(stck[['dem']])
    ch_id <- raster::getValues(stck[['channel_id']])
    
    ## work out lowest neighbour
    nc <- ncol(stck)
    nr <- nrow(stck)
    min_neighbour <- rep(NA,length(dem))
    idx <- which(!is.na(dem))
    for(ii in idx){
        ## exclude NA values from edge of area - sinks on edge are dropped later
        min_neighbour[ii] <- min(dem[fN(ii,nr,nc)],na.rm=TRUE)
    }
    
    ## determine initial sinks and missing values
    idx <- which( (min_neighbour >= dem & !is.finite(ch_id)) | dem==Inf )
    idx <- idx[order(min_neighbour[idx])]
 
    ## idx contains the list of candidate sinks - not all will be sinks...
    nit <- 0
    while(length(idx)>0 & nit < max_it){
        nit <- nit+1
        ii <- idx[1]

        ## test if it needs to change
        if( dem[ii]==Inf | (min_neighbour[ii] >= dem[ii]) ){

            ## work out neighbours
            jj <- fN(ii,nr,nc)
            dd <- dem[jj]

            if( length(dd) == 8 & !any(is.na(dd)) ){
                ## then cell is in middle of area and can be filled
                dd <- dd[is.finite(dd)]
                if(length(dd)==1){
                    dem[ii] <- dd+1e-6
                }else{
                    dem[ii] <- mean(dd)
                }
            }
            for(kk in c(ii,jj)){
                min_neighbour[kk] <- min(dem[fN(kk,nr,nc)])
            }
            ## reevaluate potential sinks
            idx <- which( (min_neighbour >= dem & !is.finite(ch_id)) | dem==Inf )
            idx <- idx[order(min_neighbour[idx])]
        }else{
            idx  <- idx[-1]
        }
    }
    
    
        
    ##     ## don't alter values on the edge of the raster
    ##     ## This stops cycling in some test cases
    ##     if( length(jj)<8 ){
    ##         idx <- idx[-1]
    ##         next
    ##     }
        
    ##     ## test if has lower neighbour
    ##     if( dem[ii]==Inf | (min_neighbour[ii] >= dem[ii]) ){
            
    ##         ## needs to change
    ##         dd <- dem[jj]
    ##         dd <- dd[is.finite(dd)]
    ##         if(length(dd)==1){
    ##             dem[ii] <- dd+1e-6
    ##         }else{
    ##             dem[ii] <- mean(dd[is.finite(dd)])
    ##         }
            
    ##         ## change all neighbour min_neighbour values
    ##         for(kk in c(ii,jj)){
    ##             min_neighbour[kk] <- min(dem[fN(kk,nr,nc)])
    ##         }
    ##         ## reevaluate potential sinks
    ##         idx <- which( (min_neighbour >= dem & !is.finite(ch_id)) | dem==Inf )
    ##         idx <- idx[order(min_neighbour[idx])]
            
    ##     }
    ## }
    
    ## copy filled dem back into stack
    stck <- raster::setValues(stck, dem, layer=which(names(stck)=="filled_dem"))
    
    if(length(stck_file)>0){
        raster::writeRaster(stck,stck_file)
        return(stck_file)
    }else{
        return(stck)
    }

}
