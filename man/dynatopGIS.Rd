% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dygis.R
\name{dynatopGIS}
\alias{dynatopGIS}
\title{R6 Class for processing a catchment to make a Dynamic TOPMODEL}
\description{
R6 Class for processing a catchment to make a Dynamic TOPMODEL

R6 Class for processing a catchment to make a Dynamic TOPMODEL
}
\examples{
## The vignettes contains more examples of the method calls.

## create temporary directory for output
demo_dir <- tempfile("dygis")
dir.create(demo_dir)

## initialise processing
ctch <- dynatopGIS$new(file.path(demo_dir,"test"))

## add a catchment outline based on the digital elevation model
dem_file <- system.file("extdata", "SwindaleDTM40m.tif", package="dynatopGIS", mustWork = TRUE)
dem <- terra::rast(dem_file)
dem <- terra::extend(dem,1)
catchment_outline <- terra::ifel(is.finite(dem),1,NA)
ctch$add_catchment(catchment_outline)

## add digital elevation and channel data
ctch$add_dem(dem)
channel_file <- system.file("extdata", "SwindaleRiverNetwork.shp",
package="dynatopGIS", mustWork = TRUE)
sp_lines <- terra::vect(channel_file)
property_names <- c(name="identifier",endNode="endNode",startNode="startNode",length="length")
chn <- convert_channel(sp_lines,property_names)
ctch$add_channel(chn)

## compute properties 
ctch$sink_fill() ## fill sinks in the catchment and computes dem flow directions
\donttest{
ctch$compute_properties() # like topograpihc index and contour length
ctch$compute_band()
ctch$compute_flow_lengths()
}
## classify and create a model
\donttest{
ctch$classify("atb_20","atb",cuts=20) # classify using the topographic index
ctch$get_method("atb_20") ## see the details of the classification
ctch$combine_classes("atb_20_band",c("atb_20","band")) ## combine classes
ctch$create_model(file.path(demo_dir,"new_model"),"atb_20_band") ## create a model
list.files(demo_dir,pattern="new_model*") ## look at the output files for the model
}
## tidy up
unlink(demo_dir)
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-dynatopGIS-new}{\code{dynatopGIS$new()}}
\item \href{#method-dynatopGIS-add_catchment}{\code{dynatopGIS$add_catchment()}}
\item \href{#method-dynatopGIS-add_dem}{\code{dynatopGIS$add_dem()}}
\item \href{#method-dynatopGIS-add_channel}{\code{dynatopGIS$add_channel()}}
\item \href{#method-dynatopGIS-add_layer}{\code{dynatopGIS$add_layer()}}
\item \href{#method-dynatopGIS-get_layer}{\code{dynatopGIS$get_layer()}}
\item \href{#method-dynatopGIS-plot_layer}{\code{dynatopGIS$plot_layer()}}
\item \href{#method-dynatopGIS-sink_fill}{\code{dynatopGIS$sink_fill()}}
\item \href{#method-dynatopGIS-compute_band}{\code{dynatopGIS$compute_band()}}
\item \href{#method-dynatopGIS-compute_properties}{\code{dynatopGIS$compute_properties()}}
\item \href{#method-dynatopGIS-compute_flow_lengths}{\code{dynatopGIS$compute_flow_lengths()}}
\item \href{#method-dynatopGIS-classify}{\code{dynatopGIS$classify()}}
\item \href{#method-dynatopGIS-combine_classes}{\code{dynatopGIS$combine_classes()}}
\item \href{#method-dynatopGIS-create_model}{\code{dynatopGIS$create_model()}}
\item \href{#method-dynatopGIS-get_version}{\code{dynatopGIS$get_version()}}
\item \href{#method-dynatopGIS-get_method}{\code{dynatopGIS$get_method()}}
\item \href{#method-dynatopGIS-clone}{\code{dynatopGIS$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-new"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-new}{}}}
\subsection{Method \code{new()}}{
Initialise a project, or reopen an existing project
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$new(projectFolder)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{projectFolder}}{folder for data files}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This loads the project data files found in the \code{projectFolder} if present. If not the folder is created. The project data files are given by \code{projectFolder/<filename>.<tif,shp>}
}

\subsection{Returns}{
A new `dynatopGIS` object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-add_catchment"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-add_catchment}{}}}
\subsection{Method \code{add_catchment()}}{
Add a catchment outline to the `dynatopGIS` project
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$add_catchment(catchment)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{catchment}}{a \code{SpatRaster} object or the path to file containing one which contains a rasterised catchment map.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If not a \code{SpatRaster} object the the catchment is read in using the terra package. Finite values in the raster indicate that the area is part of the catchment; with each subcatchment taking a unique finite value. Note that in the later processing it is assumed that outflow from the subcatchments can occur only through the channel network. The resolution and projection of the project is taken from the provided catchment
}

\subsection{Returns}{
\code{invisible(self)}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-add_dem"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-add_dem}{}}}
\subsection{Method \code{add_dem()}}{
Import a dem to the `dynatopGIS` object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$add_dem(dem, fill_na = -9999)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dem}}{a \code{raster} layer object or the path to file containing one which is the DEM}

\item{\code{fill_na}}{should NA values in dem be filled. See details}

\item{\code{verbose}}{Should additional progress information be printed}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
If not a \code{raster} the DEM is read in using the terra package. If \code{fill_na} is \code{TRUE} all NA values other then those that link to the edge of the dem are filled so they can be identified as sinks.
}

\subsection{Returns}{
suitable for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-add_channel"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-add_channel}{}}}
\subsection{Method \code{add_channel()}}{
Import channel data to the `dynatopGIS` object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$add_channel(channel, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{channel}}{a SpatVect object or file path that can be loaded as one containing the channel information}

\item{\code{verbose}}{Should additional progress information be printed}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Takes the representation of the channel network as a SpatVect with properties name, length, area, startNode, endNode and overlaying it on the DEM. In doing this a variable called id is created (or overwritten) other variables in the data frame are passed through unaltered.
}

\subsection{Returns}{
suitable for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-add_layer"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-add_layer}{}}}
\subsection{Method \code{add_layer()}}{
Add a layer of geographical information
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$add_layer(layer, layer_name = names(layer))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer}}{the raster layer to add (see details)}

\item{\code{layer_name}}{name to give to the layer}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The layer should either be a raster layer or a file that can be read by the \code{raster} package. The projection, resolution and extent are checked against the existing project data. Only layer names not already in use (or reserved) are allowed. If successful the layer is added to the project tif file.
}

\subsection{Returns}{
suitable for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-get_layer"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-get_layer}{}}}
\subsection{Method \code{get_layer()}}{
Get a layer of geographical information or a list of layer names
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_layer(layer_name = character(0))}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{name of the layer give to the layer}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a `raster` layer of the requested information if layer_name is given else a vector of layer names
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-plot_layer"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-plot_layer}{}}}
\subsection{Method \code{plot_layer()}}{
Plot a layer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$plot_layer(layer_name, add_channel = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{the name of layer to plot}

\item{\code{add_channel}}{should the channel be added to the plot}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a plot
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-sink_fill"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-sink_fill}{}}}
\subsection{Method \code{sink_fill()}}{
The sink filling algorithm of Planchona and Darboux (2001)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$sink_fill(
  min_grad = 1e-04,
  max_it = 1e+06,
  verbose = FALSE,
  hot_start = FALSE,
  flow_type = c("quinn", "d8")
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{min_grad}}{Minimum gradient between cell centres}

\item{\code{max_it}}{maximum number of replacement cycles}

\item{\code{verbose}}{print out additional diagnostic information}

\item{\code{hot_start}}{start from filled_dem if it exists}

\item{\code{flow_type}}{The type of flow routing to apply see details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The algorithm implemented is based on that described in Planchona and Darboux, "A fast, simple and versatile algorithm to fill the depressions in digital elevation models" Catena 46 (2001). A pdf can be found at (<https://horizon.documentation.ird.fr/exl-doc/pleins_textes/pleins_textes_7/sous_copyright/010031925.pdf>). The adaptations made are to ensure that all cells drain only within the subcatchments if provided.

The flow_type can be either
- "quinn" where flow is split across all downslope directions or
- "d8" where all flow follows the steepest between cell gradient
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-compute_band"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-compute_band}{}}}
\subsection{Method \code{compute_band()}}{
Computes the computational band of each cell
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$compute_band(type = c("strict"), verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{type of banding}

\item{\code{verbose}}{print out additional diagnostic information}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Banding is used within the model to define the HRUs and control the order of the flow between them; HRUs can only pass flow to HRUs in a lower numbered band. Currently only a strict ordering of river channels and cells in the DEM is implemented. To compute this the algorithm passes first up the channel network (with outlets being in band 1) then through the cells of the DEM in increasing height.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-compute_properties"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-compute_properties}{}}}
\subsection{Method \code{compute_properties()}}{
Computes statistics e.g. gradient, log(upslope area / gradient) for raster cells
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$compute_properties(min_grad = 1e-04, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{min_grad}}{gradient that can be assigned to a pixel if it can't be computed}

\item{\code{verbose}}{print out additional diagnostic information}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The algorithm passed through the cells in decreasing height. Min grad is applied to all cells. It is also used for missing gradients in pixels which are partially channel but have no upslope neighbours.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-compute_flow_lengths"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-compute_flow_lengths}{}}}
\subsection{Method \code{compute_flow_lengths()}}{
Computes flow length for each pixel to the channel
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$compute_flow_lengths(
  flow_routing = c("expected", "dominant", "shortest"),
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{flow_routing}}{TODO}

\item{\code{verbose}}{print out additional diagnostic information}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The algorithm passes through the cells in the DEM in increasing height. Three measures of flow length to the channel are computed. The shortest length (minimum length to channel through any flow path), the dominant length (the length taking the flow direction with the highest fraction for each pixel on the path) and expected flow length (flow length based on sum of downslope flow lengths based on fraction of flow to each cell). By definition cells in the channel that have no land area have a length of NA.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-classify"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-classify}{}}}
\subsection{Method \code{classify()}}{
Create a catchment classification based cutting an existing layer into classes
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$classify(layer_name, base_layer, cuts)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{name of the new layer to create}

\item{\code{base_layer}}{name of the layer to be cut into classes}

\item{\code{cuts}}{values on which to cut into classes. These should be numeric and define either the number of bands (single value) or breaks between band (multiple values).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This applies the given cuts to the supplied landscape layer to produce areal groupings of the catchment. Cuts are implement using \code{terra::cut} with \code{include.lowest = TRUE}. Note that is specifying a vector of cuts values outside the limits will be set to NA.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-combine_classes"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-combine_classes}{}}}
\subsection{Method \code{combine_classes()}}{
Combine any number of classifications based on unique combinations and burns
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$combine_classes(layer_name, pairs, burns = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{name of the new layer to create}

\item{\code{pairs}}{a vector of layer names to combine into new classes through unique combinations. Names should correspond to raster layers in the project directory.}

\item{\code{burns}}{a vector of layer names which are to be burnt on}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This applies the given cuts to the supplied landscape layers to produce areal groupings of the catchment. Burns are added directly in the order they are given. Cuts are implement using \code{terra::cut} with \code{include.lowest = TRUE}. Note that is specifying a vector of cuts values outside the limits will be set to NA.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-create_model"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-create_model}{}}}
\subsection{Method \code{create_model()}}{
Compute a Dynamic TOPMODEL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$create_model(
  layer_name,
  class_layer,
  sf_opt = c("cnst", "kin"),
  sz_opt = c("exp", "bexp", "cnst", "dexp"),
  rain_layer = NULL,
  rain_label = character(0),
  pet_layer = NULL,
  pet_label = character(0),
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{name for the new model and layers}

\item{\code{class_layer}}{the layer defining the topographic classes}

\item{\code{sf_opt}}{Surface solution to use}

\item{\code{sz_opt}}{transmissivity profile to use}

\item{\code{rain_layer}}{the layer defining the rainfall inputs}

\item{\code{rain_label}}{Prepended to rain_layer values to give rainfall series name}

\item{\code{pet_layer}}{the layer defining the pet inputs}

\item{\code{pet_label}}{Prepended to pet_layer values to give pet series name}

\item{\code{verbose}}{print more details of progress}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The \code{class_layer} is used to define the HRUs. Flow between HRUs is based on the ordering of the catchment (see the \code{compute_band} method). Flow from a HRU can only go to a HRU with a lower band.
Setting the sf_opt and sz_opt options ensures the model is set up with the correct parameters present.
The \code{rain_layer} (\code{pet_layer}) can contain the numeric id values of different rainfall (pet) series. If the value of \code{rain_layer} (\code{pet_layer}) is not \code{NULL} the weights used to compute an averaged input value for each HRU are computed, otherwise an input table for the models generated with the value "missing" used in place of the series name.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-get_version"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-get_version}{}}}
\subsection{Method \code{get_version()}}{
get the version number
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_version()}\if{html}{\out{</div>}}
}

\subsection{Details}{
the version number indicates the version of the algorithms within the object
}

\subsection{Returns}{
a numeric version number
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-get_method"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-get_method}{}}}
\subsection{Method \code{get_method()}}{
get the cuts and burns used to classify
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_method(layer_name)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{the name of layer whose classification method is returned}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a list with two elements, cuts and burns
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-dynatopGIS-clone"></a>}}
\if{latex}{\out{\hypertarget{method-dynatopGIS-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
