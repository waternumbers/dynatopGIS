% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dygis.R, R/dynatopGIS-package.R
\docType{package}
\name{dynatopGIS}
\alias{dynatopGIS}
\title{R6 Class for processing a catchment to make a Dynamic TOPMODEL}
\description{
This package contains the code for setting up a dynamic TOPMODEL implimentation
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{dynatopGIS$new()}}
\item \href{#method-list_layers}{\code{dynatopGIS$list_layers()}}
\item \href{#method-add_layer}{\code{dynatopGIS$add_layer()}}
\item \href{#method-get_layer}{\code{dynatopGIS$get_layer()}}
\item \href{#method-plot}{\code{dynatopGIS$plot()}}
\item \href{#method-add_channel}{\code{dynatopGIS$add_channel()}}
\item \href{#method-get_channel}{\code{dynatopGIS$get_channel()}}
\item \href{#method-sink_fill}{\code{dynatopGIS$sink_fill()}}
\item \href{#method-compute_properties}{\code{dynatopGIS$compute_properties()}}
\item \href{#method-classify}{\code{dynatopGIS$classify()}}
\item \href{#method-create_model}{\code{dynatopGIS$create_model()}}
\item \href{#method-neighbour}{\code{dynatopGIS$neighbour()}}
\item \href{#method-get_class}{\code{dynatopGIS$get_class()}}
\item \href{#method-get_version}{\code{dynatopGIS$get_version()}}
\item \href{#method-clone}{\code{dynatopGIS$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\subsection{Method \code{new()}}{
Reads the DEM file, sets up the raster catchment description
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$new(dem, fill_na = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{dem}}{a RasterLayer containing the dem}

\item{\code{fill_na}}{should NA values in dem be filled. See details}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Reads in the dem using the raster package. If fill_na all NA values other then those that link to the edge of the dem are filled with Inf, so they can be identified as sinks.
}

\subsection{Returns}{
A new `dynatopGIS` object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-list_layers"></a>}}
\subsection{Method \code{list_layers()}}{
List the available of geographical layers
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$list_layers(is_class = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{is_class}}{should layers of partial classification be returned}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_layer"></a>}}
\subsection{Method \code{add_layer()}}{
Add a layer of geographical information
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$add_layer(raster_layer, layer_name, check_name = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{raster_layer}}{a RasterLayer object to add}

\item{\code{layer_name}}{name to give to the layer}

\item{\code{check_name}}{logical indicating if name should be checked against reserved names}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The default is to check the name so that names reserved for computed varaibles are not overwritten. Disabling to overwrite computed layer may have unintended consequences.
}

\subsection{Returns}{
suitable for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_layer"></a>}}
\subsection{Method \code{get_layer()}}{
Get a layer of geographical information
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_layer(layer_name = character(0), is_class = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{name of the layer give to the layer}

\item{\code{is_class}}{logical if the class based on this layer should be returned}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Setting is_class to TRUE and not providing a layer_name returns the overall classification
}

\subsection{Returns}{
a RasterLayer of the requested information
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\subsection{Method \code{plot()}}{
Plot a layer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$plot(
  layer_name = character(0),
  add_channel = TRUE,
  is_class = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{layer_name}}{the name of layer to plot}

\item{\code{add_channel}}{shouel the channel be added to the plot}

\item{\code{is_class}}{logical if the class based on this layer should be returned}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Setting is_class to TRUE and not providing a layer_name returns a plot of the overall classification
}

\subsection{Returns}{
a plot
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-add_channel"></a>}}
\subsection{Method \code{add_channel()}}{
Import channel data from an OGR file to the `dynatopGIS` object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$add_channel(
  sp_object,
  property_names = c(length = "length", startNode = "startNode", endNode = "endNode",
    width = "width"),
  default_width = 2
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{sp_object}}{a spatialLinesDataFrame containing the channel information}

\item{\code{property_names}}{named vector of columns of the spatial data frame to use for channel properties}

\item{\code{default_width}}{default width of a channel if not specified in property_names. Defaults to 2 metres.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Takes the input file and covnerts it to polygons with properties length,width,startNode,endNode. The variable names in the sp_object data frame which corresponding to these properties can be specified in the \code{property_names} vector.
The function opulates the channel_id & channel_area layers and alters the land_area layer to correspond.
}

\subsection{Returns}{
suitable for chaining
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_channel"></a>}}
\subsection{Method \code{get_channel()}}{
Get the channel description
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_channel()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
an SpatialPolygonDataFrame containing the channels
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sink_fill"></a>}}
\subsection{Method \code{sink_fill()}}{
The sink filling algorithm of Planchona and Darboux 2001
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$sink_fill(
  min_grad = 1e-04,
  max_it = 1e+06,
  verbose = FALSE,
  hot_start = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{min_grad}}{Minimum gradient between cell centres}

\item{\code{max_it}}{maximum number of replacement cycles}

\item{\code{verbose}}{print out additional diagnostic information}

\item{\code{hot_start}}{start from filled_dem if it exists}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The algorithm implimented in Planchona and Darboux, "A fast, simple and versatile algorithm to fill the depressions in digital elevation models" Catena 46 (2001). A pdf can be found at https://horizon.documentation.ird.fr/exl-doc/pleins_textes/pleins_textes_7/sous_copyright/010031925.pdf.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-compute_properties"></a>}}
\subsection{Method \code{compute_properties()}}{
Computes statistics e.g. log(a/tanb) for raster cells
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$compute_properties(missing_grad = 1e-04, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{missing_grad}}{gradient that can be assigned to a pixel if it can't be computed}

\item{\code{verbose}}{print out additional diagnostic information}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The algorithm works in two passes. The first computes the number of upstream pixels and values that do not depend on ordering. The second sequences downslope to compute values. Missing gradient is only used for pixels which are partially channel but have no upslope neighbours.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-classify"></a>}}
\subsection{Method \code{classify()}}{
Split a catchment into a set hydrological response units (HRUs) according to any number of landscape layer cuts or burns
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$classify(cuts, burns = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{cuts}}{A named list of cuts of make to form the HRU. Names should correspond to raster layers in the project directory. Values should be numeric and define either the number of bands (single value) or breaks between band (multiple values)}

\item{\code{burns}}{a vector of layer names which are to be used as burns}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This applies the given cuts to the supplied landscape layers to produce areal groupings of the catchment. Burns are added directly in the order they are given.
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-create_model"></a>}}
\subsection{Method \code{create_model()}}{
Compute a Dynamic TOPMODEL
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$create_model(band = 5)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{band}}{How to cut the bands into the model, interpreted as for a cut in the classify method}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a Dynamic TOPMODE description suitable for the \code{dyantop} package
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-neighbour"></a>}}
\subsection{Method \code{neighbour()}}{
Return the index of neighbouring cells
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$neighbour(x)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{index of cells for which to find neighbours}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a list of indexes of neighbours
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_class"></a>}}
\subsection{Method \code{get_class()}}{
get the cuts and burns used to classify
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_class()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
a list with two elements, cuts and burns
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-get_version"></a>}}
\subsection{Method \code{get_version()}}{
get the version number
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$get_version()}\if{html}{\out{</div>}}
}

\subsection{Details}{
teh version number indicates the version of the algorithms within the object
}

\subsection{Returns}{
a numeric version number
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{dynatopGIS$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
