---
title: "Building a Dynamic TOPMODEL"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Building a Dynamic TOPMODEL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
                      collapse = TRUE,
                      comment = "#>"
)
```
The purpose of this vignette is to provide an outline of the steps needed to
build a dynamic TOPMODEL implementation using the dynatopGIS package.

# Principles behind dynatopGIS

The dynatopGIS package is designed to work with a structured data flow, where
by GIS data are processed through intermediate stages until one or more dynamic
TOPMODEL implementations are produced. The process GIS data of the intermediate stages are written
into files with a common directory that acts as record of the work
undertaken. Coupling this with a document such as this vignette which
documents the work flow should significantly enhance the chances of ensuring
the work is reproducible.

The basis of the analysis is presumed to be a rasterised Digital Elevation Model (DEM) of
the catchment and a vectorised representation of the river network with
attributes. Current these can be in any format supported by the ```raster``` and ```sp```
libraries.

There are however a number of limitations

-    Within the calculations of the gradient used within the sink filling,
     flow routing and topographic index calculation the raster DEM is presumed
     to be in a projection that is has square or rectangular cells such that
     the difference between the cells centers (in meters) does not alter.
-    Intermediate files are written in GeoTIFF and shapefile format. The
     GeoTIFF does not keep projection information, however the dimensions and
     projection of the original DEM are maintained

# Swindale

The use of the dynatopGIS package is demonstrated using data from the Swindale
catchment in the UK.

# Getting the data

Due to the recommended limitations on package sizes for CRAN repositories the
data for creating this vignette is not contained within the
```dynatopGIS``` package. It can be downloaded from the github repository for
the package [here](https://​github.com/​waternumbers/​dynatopGIS).

Start the analysis by loading the ```dynatopGIS``` package and specifying a
paths for both the initial data and the project to which the files generated will be written.
```{r, initialization}
library(dynatopGIS)
initial_path <- file.path("../vignette_data")
project_path <- file.path("../vignette_data/processed")
dir.create(project_path)
```

```{r, include = FALSE}
## this stops the code evaluating on CRAN
knitr::opts_chunk$set(eval = file.exists(file.path(initial_path,"SwindaleDTM4mFilled.tif"))
)
```

# Reading the DEM and River network

The package contains helper functions for reading the DEM and river
network. These read in the specified files and outputs them to the project
directory in a standard format. For the DEM this is straight forward

```{r, load_dem}
dem_file <- load_dem(file.path(initial_path, "SwindaleDTM4mFilled.tif"),
                     project_path)
raster::plot( raster::raster(file.path(project_path,'dem.tif')) )
```
As with most of the ```dynatopGIS``` functions the value `r TRUE` is
returned is the function completes successfully.

Reading the river channel data is more complex since each vector object in the
GIS file is treated as a length of river reach and requires the following
properties

-   *chanel_id* - the identifier of which model dynamic TOPMODEL channel HRU the
vector object belongs to
-   *width* - the width of the channel length
-   *endNode* - a label for the downstream end of the river length
-   *startNode* - a label for the upstream end of the river length
-   *length* - the length in meters

Currently only the channel_id and width properties are used, but it is considered in later
releases that the remaining properties will describe the connectivity of the
river network and distance from outlet.

These properties are provided to the ```load_channel``` function as a named
vector, in the case of Swindale
```{r, channel_properties}
property_names <- c(chanel_id="identifier",
                    endNode="endNode",
                    startNode="startNode",
                    length="length")
```
Since the underlying data set for Swindale does not contain a channel width we
use the default width of 2m in ```load_channel```. The river network to be imported by calling
```{r, channel_load}
load_channel(file.path(initial_path, "SwindaleRiverNetwork.shp"),
             property_names,project_path)
raster::plot( raster::shapefile(file.path(project_path,'channel')) )
```

# Combining the river network and DEM

Having loaded the channel and DEM the next stage is to combine them. The ```add_channel``` function achieves this by intersecting the
DEM and river network to determine which of the raster DEM cells contain parts
of the river network. From this three raster maps are produced containing:
-   the area in the DEM cell covered by land
-   the area in the DEM cell covered by channel
-   the id of the channel
If multiple river lengths intersect a DEM cell the id of that with the largest
intersection is used. 

For Swindale an indication of the intersected DEM cells is given in the following plot.is case combing the DEM and river network
```{r, add_channel}
print(list.files(project_path))
add_channel(project_path)
print(list.files(project_path))
raster::plot( raster::raster(file.path(project_path,'channel_id.tif')) )
```
# Filling sinks

For the hill slope to be connected to the river network the hill slope parts of
the DEM must drain to the DEM cells which intersect with the river network.

While no check is enforced on the full connectivity of the catchment a basic requirement is that there are no
sinks: that is DEM pixels which are lower then their neighbors and not
intersected by the network. The algorithm implemented in the ```sink_fill```
function tries to ensure this using a relatively simple iterative
algorithm. The execution time of the function is limited by capping the number
of iterations of the algorithm, however the algorithm can be restarted and the
minimum gradient adjust from the default of 1m in 1km.

For Swindale, where the example DEM is already partially filled the algorithm
finishes quickly and the changes in the DEM are minor
```{r, sink_fill}
sink_fill(project_path,max_iter = 1000)
raster::plot( raster::raster(file.path(project_path,'filled_dem.tif')) - raster::raster(file.path(project_path,'dem.tif')) )
```

## Computing topographic index
The basis of separation of the hydrological response units in TOPMODEL is the
topographic index, which is computed from the upstream area and gradient.

The upstream area is computed by routing down slope with the fraction of the
area being routed to the next downstream pixel being proportional to the
gradient. This can be evaluated with
```{r, calc_area}
upslope_area(project_path,max_iter = 2000)
raster::plot( raster::raster(file.path(project_path,'upslope_area.tif')))
```
This shows clearly an area of flow accumulation where no channel is defined.

The local value of the gradient (tanb) if computed using the average of a
subset of between pixel gradients. For a normal 'hill slope' cell these are the
gradients to downslope pixels. In the case of pixels which contain river
channels, or fall on the edge of the catchment with neighbors whose value is
`r NA` it is
the average of the gradients from upslope pixels.
```{r, calc_tanb}
tanb(project_path)
raster::plot( raster::raster(file.path(project_path,'tanb.tif')))
```

For Swindale the resulting topographic is calculated as
```{r, calc_atb}
atb(project_path)
raster::plot( raster::raster(file.path(project_path,'atb.tif')))
```

## Splitting into Hydrological response units
Hill slope hydrological response units can be created from the underlying data
in two ways within the ```dynatopGIS``` package. The first method, *splitting*
allows the landscape to be divided up based on breaks in the values of
landscape feature values. The second *burning* enforces classes onto distinct
area. It is presumed that burnt classes will always be imposed upon an initial
characterization through splitting.

To split a catchment into HRUs the breaks between the classes need to be
specified. This is done by forming a named ```list``` of cuts. the names
correspond to GeoTiff files within the project directory while the values of
the variables should be numeric and define either the number of bands (single
value) or breaks between split classes (multiple values).

For example to generate HRUs for Swindale by dividing the topographic index
into 21 classes and save the output classes as "atb_split.tif" in the
project folder:
```{r, atb_split}
cuts <- list(atb=20)
split_to_class(project_path,'atb_split',cuts)
raster::plot( raster::raster(file.path(project_path,'atb_split.tif')))
```

# Generating a dynamic TOPMODEL
As final stage dynamic TOPMODELs can be generated from the GIS data for use
with the ```dynatop``` package for simulation. The required model structure is
given in the vignettes of ```dynatop```, here we show that an appropriate models
can be generated with the ```compute_model``` function for a specified set of
HRUs. 

For example in the case of the division of Swindale by topographic index into
21 classes the resulting model can be generated by
```{r, model_atb_split}
create_model(project_path,'atb_split')
```

# Running a dynamic TOPMODEL

To finish this introduction we use the ```dynatop``` package to run the above
model using data from its internal example.

First we load and process the data, see the ```dynatop``` vignettes for
details.
```{r, set_input}
## load brompton data within dynatop and take observed inputs
data("brompton",package='dynatop')
obs <- dynatop::resample_xts(brompton$rain, dt = 15/60)
obs <- merge(obs,brompton$pet,all=c(TRUE,FALSE))
obs[!is.finite(obs)] <- 0
```

Next we will load the model and check it
```{r, load_model, error=TRUE, purl=FALSE}
model <- readRDS(file.path(project_path,paste0('atb_split','.rds')))
dynatop::check_model(model)

```
It fails the checks but the totals are very close to 1 so the exceedance is
likely to be due to a rounding error and is readily fixed.
```{r check_redistribution}
current_total_frac_sat <- colSums( rbind(model$Wsat,model$Fsat) )
current_total_frac_sat
current_total_frac_ex <- colSums( rbind(model$Wex,model$Fex) )
current_total_frac_ex

for(ii in names(current_total_frac_sat[current_total_frac_sat>1])){
    model$Wsat[,ii] <- model$Wsat[,ii]/current_total_frac_sat[ii]
    model$Fsat[,ii] <- model$Fsat[,ii]/current_total_frac_sat[ii]
}
for(ii in names(current_total_frac_sat[current_total_frac_ex>1])){
    model$Wex[,ii] <- model$Wex[,ii]/current_total_frac_ex[ii]
    model$Fex[,ii] <- model$Fex[,ii]/current_total_frac_ex[ii]
}
dynatop::check_model(model)
```

The available input series must match the names in the model. The observed
series names are
```{r }
head(obs)
```

while the default value of unknown is set in the model
```{r }
## model input
model$hillslope[,c('precip_input','pet_input')]
## channel inputs
model$channel[,c('precip_input','pet_input')]
```

The values are changed to allow the model to run
```{r, run_model}
model$channel$precip_input <- model$hillslope$precip_input <- "rain"
model$channel$pet_input <- model$hillslope$pet_input <- "pet"
sim <- dynatop::dynatop(model,obs,0.00012)
plot(sim$channel_input)
```

# Addendum - Burning in classes

The addendum demonstrates the burning in of additional HRU classes. Suppose in
the above example we want to burn in an additional HRU class for all areas
above 500m that aren't channels.

Firstly load the filled dem, channel index and current classification rasters

```{r burn_in_set}
filled_dem <- raster::raster(file.path(project_path,'filled_dem.tif'))
channel_index <- raster::raster(file.path(project_path,'channel_id.tif'))
atb_split <- raster::raster(file.path(project_path,'atb_split.tif'))
```

Next we will create a blank raster (populated bu NA values) to which we will
add the class to be burnt in. It is important this has the same project and
cell sizes as the original raster. The easiest way to acheive this is to
simply copy one.
```{r burn_in_blank}
Greater_500 <- filled_dem
Greater_500[] <- NA
```

Now we will assign the value of the new class to all the cells in blank raster
which belong to it. There is no checking that the class number you use is not
already in use, so we take the value to be ten greater then the maximum
already in use.
```{r burn_in_spec}
Greater_500[filled_dem > 500 & !is.finite(channel_index)] <- raster::cellStats(atb_split,'max')+10
raster::plot(Greater_500)
raster::plot(channel_index,add=TRUE,legend=FALSE)
```

Next save the new classification to the project directory
```{r burn_in_save}
raster::writeRaster(Greater_500, file.path(project_path,'Greater_500.tif'))
```
then burn it in and generate a new model
```{r burn_in_burn}
burn_in_class(project_path, 'atb_split','atb_split_500',list('Greater_500'))
plot( raster::raster(file.path(project_path,'atb_split_500.tif')) )
create_model(project_path,'atb_split_500')
```
