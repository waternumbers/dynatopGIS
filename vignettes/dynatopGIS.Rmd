---
title: "Building a Dynamic TOPMODEL"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Building a Dynamic TOPMODEL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
                      collapse = TRUE,
                      comment = "#>"
)
```
The purpose of this vignette is to provide an outline of the steps needed to
build a dynamic TOPMODEL implementation using the dynatopGIS package.

# Principles behind dynatopGIS

The dynatopGIS package is designed to work with a structured data flow, where
by GIS data are processed through intermediate stages until one or more dynamic
TOPMODEL implementations are produced. The processed GIS data are stored
within two objects; a RasterStack and a SpatialPolygonsDataFrame.

At any point in the analysis the these two objects can be written to disk and
reloaded using the commands within the ```raster``` package. There is no
formal linkage between the RasterStack and SpatialPolygonsDataFrame object so
spurious models may be produced if incorrect file combinations are used. 
Creating a document such as this vignette which
documents the work flow used should significantly enhance the chances of
ensuring the work is reproducible.

# Getting started

The basis of the analysis are a rasterised Digital Elevation Model (DEM) of
the catchment and a vectorised representation of the river network with
attributes. Current these can be in any format supported by the ```raster```
and ```sp``` libraries respectivly.

However within the calculations used for sink filling,
flow routing and topographic index calculations the raster DEM is presumed
to be projected so that is has square or rectangular cells such that
the difference between the cells centers (in meters) does not alter.

## Swindale

The use of the dynatopGIS package is demonstrated using data from the Swindale
catchment in the UK. This is included in the external data directory of the
package with the following file paths.
```{r, initialization}
#library(dynatopGIS)
devtools::load_all("/home/paul/Documents/Software/dynamic_topmodel/dynatopGIS")
dem_file <- system.file("extdata", "SwindaleDTM4mFilled.tif", package="dynatopGIS")
channel_file <- system.file("extdata", "SwindaleRiverNetwork.shp", package="dynatopGIS")
```

# Initialising the GIS objects

The package contains functions to correctly initialise the GIS objects
populated during the analysis. 

In the case of the RasterStack the initialisation function takes the DEM
(either as a rasterLayer or file name). The stack in initialised by calling
```create_brick``` as follow

```{r, create_brick}
stck <- create_catchment(dem_file)
```
The returned RasterStack has a number of layers 
```{r, brck_layers}
names(stck)
```
These are the minimum requirements for a catchment descriptiiona and are populated in the following steps. The projection information is taken from
the DEM.

Reading the river channel data data is more complex. Each vector object in the
GIS file of channel information is treated as a length of river reach and
requires the following properties

-   *endNode* - a label for the downstream end of the river length
-   *startNode* - a label for the upstream end of the river length
-   *length* - the length in meters

Additional proporties are currently ignored with two exceptions:
-   *id* - this is overwrittem with a warning and used internally
-   *width* - if the channel is specified a line sections then the *width*
    property is used to buffer the lines to create channle polygons.
	
Since it is possible that these properties are present in the current data but
under different names the ```create_channel``` function allows for
renaming. To illustrate this let us examine the river network for Swindale

```{r, channel_current}
shp <- rgdal::readOGR(channel_file)
head(shp)
```

The main properties are present under appropriate names and a call to
```create_channel``` with no options would be successful. However if we want to carry over the addition information in the "indentifier" as "channel_id" a
named vector giving the variable names to be used could be provided. In this
case:

```{r, channel_properties}
property_names <- c(channel_id="identifier",
                    endNode="endNode",
                    startNode="startNode",
                    length="length")
```

Since the data set for Swindale does not contain a channel width we
use the default width of 2m in ```create_channel```. The river network can
then be created in the correct format by
```{r, channel_load}
chn <- create_channel(shp,property_names)
head(chn@data)
```

The resulting data can be plotted using standard ```raster``` package commands
```{r, plot_raw}
raster::plot(stck[['dem']])
raster::plot(chn,add=TRUE)
```

# Combining the river network and DEM

Having initialised the analysis the next stage is to combine the DEm and
channel network. The ```add_channel``` function achieves this by intersecting
the DEM and river network to determine which of the raster cells contain
parts of the river network. From this three layers of the brick are populated:
-   land_area - the area in the DEM cell covered by land
-   channel_area - the area in the DEM cell covered by channel
-   channel_id - the id of the channel within the cell, corresponding to
the id in the channel object.

If multiple river lengths intersect a DEM cell the properties of the channel
length with the largest area of intersection are used. 

The following shows the impact of the properties of the raster brick after
applying the channel network in Swindale.

```{r, add_channel}
#print(stck)
#print(chn)
stck <- add_channel(stck,chn)
#print(stck)
```

# Filling sinks

For the hill slope to be connected to the river network the hill slope parts of
the DEM must drain to the DEM cells which intersect with the river network.

While no check is enforced on the full connectivity of the catchment a basic requirement is that there are no
sinks: that is DEM pixels which are lower then their neighbors and not
intersected by the network. The algorithm implemented in the ```sink_fill```
function tries to ensure this using a relatively simple iterative
algorithm. The execution time of the function is limited by capping the number
of iterations of the algorithm, however the algorithm can be restarted and the
minimum gradient adjust from the default of 1m in 1km.

For Swindale, where the example DEM is already partially filled the algorithm
finishes quickly and the changes in the DEM are minor
```{r, sink_fill}
stck <- sink_fill(stck)
raster::plot( stck[['filled_dem']] - stck[['dem']] )
```

## Computing summary properties

The basis of separation of the hydrological response units in TOPMODEL is the
topographic index, which is computed from the upstream area and gradient.

These are computed using the formulea in Quinn 1991 (TO DO add ref).

The upstream area is computed by routing down slope with the fraction of the
area being routed to the next downstream pixel being proportional to the
gradient times the contour length. 

The local value of the gradient is computed using the average of a
subset of between pixel gradients. For a normal 'hill slope' cell these are the
gradients to downslope pixels weighted by contour length. In the case of
pixels which contain river channels the average of the gradients from upslope
pixels weighted by contour length us used.

These properties (and others) are computed in an algorithm that passes over
the data twice. First to compute identify 'peaks' in the dem, dsecondly to
travel downslope. It is called as follows
```{r, calc_atb}
stck <- compute_properties(stck)
## plot of topographic index (log(a/tan b))
raster::plot( stck[['atanb']])
## plot of order of pixels (1 highest)
raster::plot( stck[['order']] )
```

## Splitting into Hydrological response units

Hill slope hydrological response units can be created from the underlying data
in two ways within the ```dynatopGIS``` package. The first method, *splitting*
allows the landscape to be divided up based on breaks in the values of
landscape feature values. The second *burning* enforces classes onto distinct
area. It is presumed that burnt classes will always be imposed upon an initial
characterization through splitting.

### Splitting

To split a catchment into HRUs the breaks between the classes need to be
specified. This is done by forming a named ```list``` of cuts. the names
correspond to GeoTiff files within the project directory while the values of
the variables should be numeric and define either the number of bands (single
value) or breaks between split classes (multiple values).

For example to generate HRUs for Swindale by dividing the topographic index
into 21 classes and save the output classes as "atb_split.tif" in the
project folder:
```{r, atb_split}
cuts <- list(atanb=20)
stck <- split_to_class(stck,'atb_split',cuts)
raster::plot( stck[['atb_split']] )
```
TO DO comment of sequential numbering used

### Burns

Suppose in the above example we want to burn in an additional HRU class for
all areas above 500m that aren't channels.

Firstly we add an additional layer to the brick to which these locations are
identified.
```{r burn_in_set}
stck[['greater_500']] <- raster::reclassify(stck[['filled_dem']],
                                            matrix(c(0,500,NA,
                                                     500,1000,raster::cellStats(stck[['atb_split']],'max')+1),2,byrow=TRUE))
```
Note we have given the cells a value of one greater then the maximum value of
splits we will burn this into to maintain the sequential numbering of the HRUs

It can then be burnt in as follows
```{r burn_in}
stck <- burn_in_class(stck,"atb_split","atb_500_split",list("greater_500"))
raster::plot(stck[["atb_500_split"]])
```

# Generating a dynamic TOPMODEL
As final stage dynamic TOPMODELs can be generated from the GIS data for use
with the ```dynatop``` package for simulation. The required model structure is
given in the vignettes of ```dynatop```, here we show that an appropriate models
can be generated with the ```compute_model``` function for a specified set of
HRUs. 

For example in the case of the division of Swindale by topographic index into
21 classes the resulting model can be generated by
```{r, model_atb_split}
model <- create_model(stck,chn,'atb_split')
```

We can then use the duynatop package to check the validity of the model
```{r check_model}
# dynatop::check_model(model)
```
