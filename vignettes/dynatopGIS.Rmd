---
title: "Building a Dynamic TOPMODEL"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Building a Dynamic TOPMODEL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
The purpose of this vignette is to provide an outline of the steps needed to
build a dynamic TOPMODEL implimentation using the dynatopGIS package.

# Principles behind dynatopGIS

The dynatopGIS package is designed to work with a structured data flow, where
by GIS data are processed through intermediate stages until one or more dynamic
TOPMODEL implimentations are produced. The process GIS data of the intermediate stages are written
into files with a common directory that acts as record of the work
undertaken. Coupling this with a document such as this vignette which
documents the workflow should significantly enhance the chances of ensuring
the work is reproducable.

The basis of the analysis is presumed to be a rasterised Digital Elevation Model (DEM) of
the catchment and a vectorised representation of the river network with
attributes. Current these can be in any format supported by the \code{raster} and \code{sp}
libraries.

There are however a number of limitations
* Within the calculations of the gradient used within the sink filling, flow routing and
  topographic index calculation the raster DEM is presumed to be in a
  projection that is has square or rectangular cells such that the difference
  between the cells centers (in meters) does not alter.
* Intermediate files are written in GeoTIFF and shapefile format. The GeoTIFF does not keep
  projection information, however the dimensions asn projection of the
  original DEM are maintained

# Swindale

The use of the dynatopGIS package is demonstrated using data from the Swindale
catchment in the UK.

# Reading the DEM and River network

Start the analysis by loading the \code{dynatopGIS} package and specifying a
path for the project to which the intermediate files will be written.
```{r, initialisation}
devtools::load_all()
## library(dynatopGIS)
project_path <- tmpDir()
```
The package contains helper functions for reading the DEM and river
network. These read in the specified files and outputs them to the project
directory in a standard format. For the DEM this is straight forward
```{r, load_dem}
load_dem(system.file("extdata", "SwindaleDTM4mFilled.tif", package = "dynatopGIS", mustWork = TRUE),
         project_path)

plot( raster::raster(file.path(project_path,'dem.tif')) )
```
As with most of the \code{dynatopGIS} functions the value \code{TRUE} is
returned is the function completes successfully.

Reading the river channel data is more complex since each vector object in the
GIS file is treated as a length of river reach and requires the following
properties
* *chanel_id* - the identifier of which model dynamic TOPMODEL channel HRU the
vector object belongs to
* *width* - the width of the channel length
* *endNode* - a label for the downstream end of the river length
* *startNode* - a label for the upstream end of the river length
* *length* - the length in meters

Currently only the channel_id and width properties are used, but it is considered in later
releases that the remaining properties will describe the connectivity of the
river network and distance from outlet.

These properties are provided to the \code{load_channel} function as a named
vector, in the case of Swindale
```{r, channel_properies}
property_names <- c(chanel_id="identifier",
                    endNode="endNode",
                    startNode="startNode",
                    length="length")
```
Since the underlying data set for Swindale does not contain a channel width we
use the default width of 2m in \code{load_channel}. The river network to be imported by calling
```{r, channel_load}
load_channel( system.file("extdata", "SwindaleRiverNetwork.shp", package = "dynatopGIS", mustWork = TRUE),
            property_names,project_path)
plot( raster::shapefile(file.path(project_path,'channel')) )
```

# Combing the channel to the River network

Having loaded the channel and DEM the next stage is to combine the channel network
and the DEM. the \code{add_channel} function acheives this by intersecting the
DEM and river network to determine which of the raster DEM cells contain parts
of the river network. From this three raster maps are produced containing:
* the area in the DEM cell covered by land
* the area in the DEM cell covered by channel
* the id of the channel
If multiple river lengths intersect a DEM cell the id of that with the largest
intersection is used. 

For Swindale an indication of the intersected DEM cells is given int
he follwoing plot.is case combing the DEM and river network
```{r, add_channel}
add_channel(project_path)
plot( raster::raster(file.path(project_path,'channel_id.tif')) )
```
# Filling sinks

For the hillslope to be connected to the rivernework the hillslope parts of
the DEM but drain to the DEM cells which intersect with the river network.

While no check is enforced on the full connectivity ofthe catchment a basic requirement is that there are no
sinks: that is DEM pixels which are lower then their neighbours and not
intersected by the network. The algorithm implimented in the \code{sink_fill}
function tries to ensure this using a relatively simple iterative
algorithm. te execution time of the function is limited by capping the number
of iterations of the algorithm, howver the algorithm can be restarted and the
minimum gradient adjuest from the default of 1m in 1km.

For Swindale, where the example DEM is already partially filled the algorithm
finishes quickly and the changes in the DEM are minor
```{r, sink_fill}
sink_fill(project_path,max_iter = 1000)
plot( raster::raster(file.path(project_path,'filled_dem.tif')) - raster::raster(file.path(project_path,'dem.tif')) )
```

## Computing topographic index
The basis of seperation of the hydrological response units in TOPMODEL is the
topographic index.
This can be computed by the the function \code{cal_atb} which impliments an
algorithm that computes the area draining to a cell from those upstream
presuming the flow is split between the downsteam (lower) neighbouring cells
proportional to the gradient.

For Swindale the resulting topographic is calculated as
```{r, calc_atb}
calc_atb(project_path,max_iter = 2000)
plot( raster::raster(file.path(project_path,'atb.tif')))
```

## Spliting into Hydrological response units
Hillslope hydrological response units can be created from the underlying data
in two ways within the \code{dynatopGIS} package. The first method, *spliting*
allows the landscep to be divided up based on breaks in the values of
landscape feature values. The second *burning* enforeces classes onto distinct
area. It is presumed that burnt classes will always be imposed upon an initial
characterisation through splitting.

To split a catchment into HRUs the breaks between the classes need to be
specified. This is done by forming a named \code{list} of cuts. the names
correspond to GeoTiff files within the project directory while teh values of
the variables should be numeric and define either the number of bands (single
value) or breaks between split classes (multiple values).

For example to generate HRUs for Swindale by dividing the topographic index
into 21 classes and sve the output classes as \code{atb_split.tif} in the
project folder:
```{r, atb_split}
cuts <- list(atb=20)
split_to_class(project_path,'atb_split',cuts)
plot( raster::raster(file.path(project_path,'atb_split.tif')))
```


# Generating a dynamic TOPMODEL
As final stage dynamic TOPMODELs can be generated from the GIS data for use
with the code{dynatop} package for simulation. The required model structure is given
in the vignettes of \code{dynatop}, here we show that an appropriate models
can be generated with the \code{compute_model} function for a specified set of
HRUs. 

For example in the case of the division of Swindale by togographic index into
21 classes the resulting model can be generated and displayed by
```{r, mode_atb_split}
create_model(project_path,'atb_split')
```
